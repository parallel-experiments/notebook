{
  "paths": [
    {
      "type": "file",
      "value": "index.md"
    },
    {
      "type": "file",
      "value": "asgi-dispatcher-middleware.md"
    },
    {
      "type": "file",
      "value": "clojure-unknown-tool-tools.md"
    },
    {
      "type": "file",
      "value": "mongodb-mass-removing-nested-array-element-property.md"
    },
    {
      "type": "file",
      "value": "python-pydantic-unprintable-validationerror-object.md"
    }
  ],
  "contents": [
    {
      "path": "index.md",
      "url": "index.html",
      "content": "# Welcome to this notebook!\n\nHere I write notes about obscure or forgettable issues I commonly have to deal with.\n\n---\n\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>",
      "html": "<h1 id=\"welcome-to-this-notebook!\">Welcome to this notebook! <a class=\"heading-anchor-permalink\" href=\"#welcome-to-this-notebook!\">#</a></h1>\n<p>Here I write notes about obscure or forgettable issues I commonly have to deal with.</p>\n<hr>\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>",
      "id": 0
    },
    {
      "path": "asgi-dispatcher-middleware.md",
      "url": "asgi-dispatcher-middleware.html",
      "content": "# ASGI dispatcher middleware\n\nThere is, sometimes, a scenario in which two or more different Python web frameworks have to be ran at the same location.\n\nUsually one would start two different runtimes and point a reverse proxy to two different servers behind slightly different subdomains/subdirectories (paths) and call it a day.\nThis works for any kind of combination of HTTP servers and programming languages they are implemented in.\n\nHowever, there are also scenarios where best course of action would be to have the exact same runtime/interpreter serve multiple different web servers.\nThis is also possible in a way but what if we want to go a step further and have the exact same interpreter/runtime and the exact same TCP server serve multiple different web applications implemented in multiple different codebases?\n\n### Solution\n\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/direct?nonce=abc123\t\"></iframe>\n\nEnter Werkzeug Dispatcher Middleware.\n\nBut first, a quick detour for a primer on WSGI;\n\nPython WSGI standard is a specification contract forcing web-application developers to conform to a single behavior:\n\n1. a web app starts with a single Python function\n2. the function takes in two arguments, a request environment and a typing.Callable\n3. the function uses request environment to create a response (in reality this is the application entrypoint)\n4. the function calls the typing.Callable it was given with a status code and response headers\n5. the function returns a typing.Iterable of response body(/ies)\n\nThis means every single web application conforming to this standard works exactly the same.\n\n--\n\nBack to Dispatcher Middleware;\n\na dispatcher is an entrypoint, a WSGI application that passes requests through to other WSGI applications.\nRemember how all WSGI applications need to conform to a specific structure? What it means is - you can dynamically decide which applications are used in which scenarios. Yes that includes Django and Flask (and probably many other combinations).\n\nWerkzeug (and probably many more) packages provide this in one way or another, but for WSGI.\n\nWhat about ASGI?\n\nYou will find a couple packages on Pypi addressing this case but mostly one-off packages written and maintained by one person, which might not be suitable for your requirements.\n\n---\n\nWhy one person? Because you can write one yourself in a 16 line function with 0 (zero) dependencies:\n\n```python\nasync def dispatch(scope, receive, send):                                       \n    default_app = djangoapp                                                     \n    patterns: dict = {\"/flask\": flaskapp, \"/django\": djangoapp}                       \n\n    app = None                                                                  \n                                                                                \n    for _path, _app in patterns.items():                                        \n        if not _path.startswith(scope[\"path\"]):                                 \n            continue                                                            \n                                                                                \n        app = _app                                                              \n        break                                                                   \n                                                                                \n    if app is None:                                                             \n        app = default_app                                                       \n                                                                                \n    await app(scope, receive, send)\n```\n\nYou can add as many improvements and changes to this as you'd like it's just a minimal working example and I didn't yet go into type definitions or performance improvements.\n\nAll credit goes to c-bata (https://github.com/c-bata, https://c-bata.medium.com/) their github gist is where I finally figured out the dots to connect: https://gist.github.com/c-bata/b77f068fc1a16e55792e8b6154dd8354",
      "html": "<h1 id=\"asgi-dispatcher-middleware\">ASGI dispatcher middleware <a class=\"heading-anchor-permalink\" href=\"#asgi-dispatcher-middleware\">#</a></h1>\n<p>There is, sometimes, a scenario in which two or more different Python web frameworks have to be ran at the same location.</p>\n<p>Usually one would start two different runtimes and point a reverse proxy to two different servers behind slightly different subdomains/subdirectories (paths) and call it a day.\nThis works for any kind of combination of HTTP servers and programming languages they are implemented in.</p>\n<p>However, there are also scenarios where best course of action would be to have the exact same runtime/interpreter serve multiple different web servers.\nThis is also possible in a way but what if we want to go a step further and have the exact same interpreter/runtime and the exact same TCP server serve multiple different web applications implemented in multiple different codebases?</p>\n<h3 id=\"solution\">Solution <a class=\"heading-anchor-permalink\" href=\"#solution\">#</a></h3>\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/direct?nonce=abc123\t\"></iframe>\n<p>Enter Werkzeug Dispatcher Middleware.</p>\n<p>But first, a quick detour for a primer on WSGI;</p>\n<p>Python WSGI standard is a specification contract forcing web-application developers to conform to a single behavior:</p>\n<ol>\n<li>a web app starts with a single Python function</li>\n<li>the function takes in two arguments, a request environment and a typing.Callable</li>\n<li>the function uses request environment to create a response (in reality this is the application entrypoint)</li>\n<li>the function calls the typing.Callable it was given with a status code and response headers</li>\n<li>the function returns a typing.Iterable of response body(/ies)</li>\n</ol>\n<p>This means every single web application conforming to this standard works exactly the same.</p>\n<p>–</p>\n<p>Back to Dispatcher Middleware;</p>\n<p>a dispatcher is an entrypoint, a WSGI application that passes requests through to other WSGI applications.\nRemember how all WSGI applications need to conform to a specific structure? What it means is - you can dynamically decide which applications are used in which scenarios. Yes that includes Django and Flask (and probably many other combinations).</p>\n<p>Werkzeug (and probably many more) packages provide this in one way or another, but for WSGI.</p>\n<p>What about ASGI?</p>\n<p>You will find a couple packages on Pypi addressing this case but mostly one-off packages written and maintained by one person, which might not be suitable for your requirements.</p>\n<hr>\n<p>Why one person? Because you can write one yourself in a 16 line function with 0 (zero) dependencies:</p>\n<pre><code class=\"language-python\">async def dispatch(scope, receive, send):                                       \n    default_app = djangoapp                                                     \n    patterns: dict = {&quot;/flask&quot;: flaskapp, &quot;/django&quot;: djangoapp}                       \n\n    app = None                                                                  \n                                                                                \n    for _path, _app in patterns.items():                                        \n        if not _path.startswith(scope[&quot;path&quot;]):                                 \n            continue                                                            \n                                                                                \n        app = _app                                                              \n        break                                                                   \n                                                                                \n    if app is None:                                                             \n        app = default_app                                                       \n                                                                                \n    await app(scope, receive, send)\n</code></pre>\n<p>You can add as many improvements and changes to this as you’d like it’s just a minimal working example and I didn’t yet go into type definitions or performance improvements.</p>\n<p>All credit goes to c-bata (<a href=\"https://github.com/c-bata\">https://github.com/c-bata</a>, <a href=\"https://c-bata.medium.com/\">https://c-bata.medium.com/</a>) their github gist is where I finally figured out the dots to connect: <a href=\"https://gist.github.com/c-bata/b77f068fc1a16e55792e8b6154dd8354\">https://gist.github.com/c-bata/b77f068fc1a16e55792e8b6154dd8354</a></p>\n",
      "id": 1
    },
    {
      "path": "clojure-unknown-tool-tools.md",
      "url": "clojure-unknown-tool-tools.html",
      "content": "# Unknown tool: tools\n\nCommonly presents as an error during an attempt to add Sean Corfield's \"new\" like so\n\n```\nclojure -Ttools install com.github.seancorfield/clj-new '{:git/tag \"v1.2.381\"}' :as new\n```\n\nand the error \n\n```Error building classpath. Unknown tool: tools```\n\n### Solution\n\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/direct?nonce=abc123\t\"></iframe>\n\n(https://clojurians-log.clojureverse.org/clj-on-windows/2022-09-01) is to create `~/.clojure/tools/tools.edn` and add in\n\n```\n{:lib io.github.clojure/tools.tools\n :coord {:git/tag \"v0.2.8\"\n         :git/sha \"9c5baa56cff02de98737a71d4dab098b268cd68b\"}}\n\n```\nor newer before re-running.\n",
      "html": "<h1 id=\"unknown-tool%3A-tools\">Unknown tool: tools <a class=\"heading-anchor-permalink\" href=\"#unknown-tool%3A-tools\">#</a></h1>\n<p>Commonly presents as an error during an attempt to add Sean Corfield’s “new” like so</p>\n<pre><code>clojure -Ttools install com.github.seancorfield/clj-new '{:git/tag &quot;v1.2.381&quot;}' :as new\n</code></pre>\n<p>and the error</p>\n<p><code>Error building classpath. Unknown tool: tools</code></p>\n<h3 id=\"solution\">Solution <a class=\"heading-anchor-permalink\" href=\"#solution\">#</a></h3>\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/direct?nonce=abc123\t\"></iframe>\n<p>(<a href=\"https://clojurians-log.clojureverse.org/clj-on-windows/2022-09-01\">https://clojurians-log.clojureverse.org/clj-on-windows/2022-09-01</a>) is to create <code>~/.clojure/tools/tools.edn</code> and add in</p>\n<pre><code>{:lib io.github.clojure/tools.tools\n :coord {:git/tag &quot;v0.2.8&quot;\n         :git/sha &quot;9c5baa56cff02de98737a71d4dab098b268cd68b&quot;}}\n\n</code></pre>\n<p>or newer before re-running.</p>\n",
      "id": 2
    },
    {
      "path": "mongodb-mass-removing-nested-array-element-property.md",
      "url": "mongodb-mass-removing-nested-array-element-property.html",
      "content": "# Mass removing a property from an object that's an element in an array property\n\nNoting this case because finding a solution or docs on it is not easy and the functionality is not discoverable. I myself forgot about it and had to re-find it a couple of times.\n\nScenario is when a document has a `.things` property that's an array of objects, and one of the properties (e.g. `.things[].stuff` has to be mass removed.\nUnsetting the nested property by doing an `updateOne(lookup, {$unset: {\"things.stuff\": 1}})` or `$unset: {\"things.$.stuff\": 1}` does not work.\n\n### Solution\n\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>\n\nAs seen here https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/\n\nThe \"all positional operator\", `$[]` indicates that the update operator should modify all elements in the specified array field.\nDoing `updateOne(lookup, {$unset: {\"things.$[].stuff\": 1}})` will successfully clean out the property from objects in the document's `.things` array.\n",
      "html": "<h1 id=\"mass-removing-a-property-from-an-object-that%E2%80%99s-an-element-in-an-array-property\">Mass removing a property from an object that’s an element in an array property <a class=\"heading-anchor-permalink\" href=\"#mass-removing-a-property-from-an-object-that%E2%80%99s-an-element-in-an-array-property\">#</a></h1>\n<p>Noting this case because finding a solution or docs on it is not easy and the functionality is not discoverable. I myself forgot about it and had to re-find it a couple of times.</p>\n<p>Scenario is when a document has a <code>.things</code> property that’s an array of objects, and one of the properties (e.g. <code>.things[].stuff</code> has to be mass removed.\nUnsetting the nested property by doing an <code>updateOne(lookup, {$unset: {&quot;things.stuff&quot;: 1}})</code> or <code>$unset: {&quot;things.$.stuff&quot;: 1}</code> does not work.</p>\n<h3 id=\"solution\">Solution <a class=\"heading-anchor-permalink\" href=\"#solution\">#</a></h3>\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>\n<p>As seen here <a href=\"https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/\">https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/</a></p>\n<p>The “all positional operator”, <code>$[]</code> indicates that the update operator should modify all elements in the specified array field.\nDoing <code>updateOne(lookup, {$unset: {&quot;things.$[].stuff&quot;: 1}})</code> will successfully clean out the property from objects in the document’s <code>.things</code> array.</p>\n",
      "id": 3
    },
    {
      "path": "python-pydantic-unprintable-validationerror-object.md",
      "url": "python-pydantic-unprintable-validationerror-object.html",
      "content": "# Pydantic ValidationError with unprintable ValidationError object\n\nIn some cases (NOT always), using Pydantic in a Python project will fail with an \"unprintable\" validation error, resulting in stack breaking with an exception similar to\n\n```\npydantic.error_wrappers.ValidationError: <unprintable ValidationError object>\n```\n\nand while I couldn't find the time to exactly find what causes this and how to handle it elegantly;\n\n### Solution\n\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>\n\na quick solution that I found is to try to instantiate some or any of the Pydantic types as early as possible.\nIn other words, this problem arises when\n\n```python\nfrom pydantic import BaseModel\n\nclass B(BaseModel):\n    some_property: int\n\nclass A(BaseModel):\n    b: B\n\ndef example() -> A:\n    b = {\"another_property\": None}\n    return A(**{\"b\": b}) # => raises an \"unprintable\" ValidationError with no extra info\n```\n\nmeaning that validating inner types earlier like so\n\n```python\n\ndef example() -> A:\n    b = {\"another_property\": None}\n    B(**b) # => raises a \"printable\" ValidationError, b.some_property # Field required [type=missing, input_value={'another_property': None}, input_type=dict]\n\n    return A(**{\"b\": b})\n```\n\nis a sensible approach to avoiding this type of issue.\n",
      "html": "<h1 id=\"pydantic-validationerror-with-unprintable-validationerror-object\">Pydantic ValidationError with unprintable ValidationError object <a class=\"heading-anchor-permalink\" href=\"#pydantic-validationerror-with-unprintable-validationerror-object\">#</a></h1>\n<p>In some cases (NOT always), using Pydantic in a Python project will fail with an “unprintable” validation error, resulting in stack breaking with an exception similar to</p>\n<pre><code>pydantic.error_wrappers.ValidationError: &lt;unprintable ValidationError object&gt;\n</code></pre>\n<p>and while I couldn’t find the time to exactly find what causes this and how to handle it elegantly;</p>\n<h3 id=\"solution\">Solution <a class=\"heading-anchor-permalink\" href=\"#solution\">#</a></h3>\n<iframe src=\"https://microads.ix.tc/api/ads/delivery-node/random?nonce=abc123\"></iframe>\n<p>a quick solution that I found is to try to instantiate some or any of the Pydantic types as early as possible.\nIn other words, this problem arises when</p>\n<pre><code class=\"language-python\">from pydantic import BaseModel\n\nclass B(BaseModel):\n    some_property: int\n\nclass A(BaseModel):\n    b: B\n\ndef example() -&gt; A:\n    b = {&quot;another_property&quot;: None}\n    return A(**{&quot;b&quot;: b}) # =&gt; raises an &quot;unprintable&quot; ValidationError with no extra info\n</code></pre>\n<p>meaning that validating inner types earlier like so</p>\n<pre><code class=\"language-python\">\ndef example() -&gt; A:\n    b = {&quot;another_property&quot;: None}\n    B(**b) # =&gt; raises a &quot;printable&quot; ValidationError, b.some_property # Field required [type=missing, input_value={'another_property': None}, input_type=dict]\n\n    return A(**{&quot;b&quot;: b})\n</code></pre>\n<p>is a sensible approach to avoiding this type of issue.</p>\n",
      "id": 4
    }
  ]
}